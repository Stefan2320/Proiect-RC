BrowserFS =  in-browser file system 
Are urmatoarele functii:
	BFSRequire(module: "fs"): FSModule // pentru initializarea tipului de date sa fie FS
    	BFSRequire(module: "path"): "path"
    	BFSRequire(module: "buffer"): "buffer"
    	BFSRequire(module: "process"): Process
    	BFSRequire(module: "bfs_utils"): "core/util"
    	BFSRequire(module: string): any

	configure(config: FileSystemConfiguration, cb: BFSOneArgCallback): void // easily configure BrowserFS to use a variety of file system types
	??( se alege de unde se va citi informatia din backend si apoi cu ce configuratie de exemplu daca avem fisiere.zip  il configuram intr-un anumit mod. )??
													
	getFileSystem(config: FileSystemConfiguration, cb: BFSCallback<FileSystem>): void // reprimieste un fisier de sistem cu o anumita configuratie

	initialize(rootfs: FileSystem): FileSystem // initializeaza BorwserFS cu radacina sistemului de fisiere
	
	install(obj: any): void // BFSRequire devine global ( alternativa la configure ?)


CoAp = Constrained Application Protocol 

-A fost facut pentru IoT ( INternet of Things)
-Inspirat din HTTP
-Foloseste UDP (si IP)?
-UDP, metoda de transport, e rapida insa nu la fel de sigura ca TCP, TCP asteapta confirmare ca receptorul a primit mesajul, UDP trimite tot fara verificare.
-Comunicare 1 to 1 protocol -> GET,POST,PUT,DELETE
-Bun pentru sisteme mici,memorie RAM si ROM mica, baterie limitata, sisteme embedded ?
-Ce e diferit fata de HTTP? 
	-Observe ( anunta cand se schimba starea unui falg)
	-Discovery ( trimite date despre ce dispozitive sunt conectate??)
-CoAP defines four types of messages:
   Confirmable, Non-confirmable, Acknowledgement, Reset
   
https://github.com/jvilk/browserfs
https://jvilk.com/browserfs/1.4.1/index.html
https://jvilk.com/browserfs/1.4.1/modules/_core_browserfs_.html#getfilesystem
https://datatracker.ietf.org/doc/html/rfc7252 - 


--Mesaje--

Request si response au un header fix de 4 bytes.
Fiecare mesaj contine un Message ID de 16 biti folosit pentru a detecta mesajele duplicate

Mesajele pot fi confirmable(CON), mesajele se trimit pana cand cel care trebuie sa primeasca trimite un Acknowledgment message(ACK) cu acelasi Message ID. Daca nu se reuseste transmisia, atunci se trimite Reset Message(RST).
Mesajele pot fi si non-confirmable(NON), acestea nu trebue sa fie acknowledged, dar tot trebuie sa aiba un Message ID pentru a gasi duplicatele. Daca nu pot fi procesate
receptorul poate raspunde cu un RST.

---Request---

Cererile pot fi atat CON cat si NON, iar daca sunt CON, atunci raspunsul poate fi transmis in mesajul de acknowledgement(acest proces se numeste piggybacked response) daca raspunsul este instant valabil. Daca raspunsul nu este gata instant, atunci se trimite un ACK gol(pentru ca clientul sa nu mai retrimita cererea), iar raspunsul se trimite cand este gata(tot sub forma unui CON).
Daca cererile sunt NON, serverul poate raspunde cu un mesaj NON sau CON.



	
